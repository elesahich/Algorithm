## [42892 : ê¸¸ì°¾ê¸° ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/42892)

- ëŠë‚€ì 

1. ê¸°ë³¸ íŠ¸ë¦¬ ë¬¸ì œì“° </br>
2. if ë¶„ê¸°ê°€ ë„ˆë¬´ ë§ì€ë°,,, ìµœì†Œí™” í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€ ëª°ê¹Œìš¤ </br>

- ê³ ë ¤í•´ì•¼í•  ì  :

1. ì¬ê·€í•¨ìˆ˜ íƒ€ì´ë°ì„ ì˜ ë§ì¶°ì£¼ê³ 
2. Classë¡œ ë§Œë“¤ì–´ì¤˜ì•¼ í•¨ </br>

## ğŸ“Œ í’€ì´

1. root, currentë¡œ í’€ì—ˆë‹¤. rootì—ì„œ currentë¥¼ íƒ€ê³  ë‚´ë ¤ê°€ë©´ì„œ </br>
   `nil`ì¸ ê²½ìš° ì‚½ì…, `nil`ì´ ì•„ë‹Œ ê²½ìš° ë¹„êµë¥¼ í•˜ê²Œ ë˜ì—ˆë‹¤ -> ì–´ì©” ìˆ˜ ì—†ì´ ê·¸ë˜ì„œ ë¹„êµë¥¼ ì“¸ ìˆ˜ë°–ì— ì—†ì§€ ì•Šë‚˜...

íŠ¸ë¦¬ êµ¬ì¡°

```swift
public class BinaryNode<T> {
    public var value: T
    public var leftChild: BinaryNode?
    public var rightChild: BinaryNode?
    public init(value: T) {
        self.value = value
    }
    public func traverseInOrder(visit: (T) -> Void) {
        leftChild?.traverseInOrder(visit: visit)
        visit(value)
        rightChild?.traverseInOrder(visit: visit)
    }
    public func traversePreOrder(visit: (T) -> Void) {
        visit(value)
        leftChild?.traversePreOrder(visit: visit)
        rightChild?.traversePreOrder(visit: visit)
    }
    public func traversePostOrder(visit: (T) -> Void) {
        leftChild?.traversePostOrder(visit: visit)
        rightChild?.traversePostOrder(visit: visit)
        visit(value)
    }
}
```

_1._
BinaryNodeì— ê·¸ëƒ¥ ì •ìˆ˜ë§Œ ë°›ì•„ì•¼ í•˜ëŠ”ê°€ ê³ ë¯¼ì„ ë§ì´ í–ˆëŠ”ë° </br>
valueë¥¼ ë¹„êµë¥¼ í•  ìˆ˜ê°€ ì—†ë”ë¼. ê·¸ë˜ì„œ ì–´ì©”ìˆ˜ ì—†ì´ `BinaryNode<[Int]>`ê°€ ë¨
ê·¸ ì´í›„ì—ëŠ” í° ë¬¸ì œê°€ ì—†ë‹¹

```swift
func solution(_ nodeinfo: [[Int]]) -> [[Int]] {
    // 0 : Input Arrayì˜ Index, 1 : ì •ë ¬ëœ Arrayì˜ Xê°’, 2: ì •ë ¬ëœ Arrayì˜ Yê°’
    var tuple: [[Int]] = []
    for index in 0..<nodeinfo.count {
        tuple.append([index + 1,
                      nodeinfo[index][0],
                      nodeinfo[index][1]])
    }
    let inputArray = tuple.sorted(by: { $0[2] > $1[2] })
    let root: BinaryNode<[Int]> = BinaryNode(value: inputArray[0])


    for index in 0..<inputArray.count {
        guard index != 0 else { continue }
        if root.value[1] > inputArray[index][1] {
            if root.leftChild == nil {
                root.leftChild = BinaryNode(value: inputArray[index])
            } else {
                guard let current = root.leftChild else { continue }
                setupBinaryTree(inputArray, current, index)
            }
        } else {
            if root.rightChild == nil {
                root.rightChild = BinaryNode(value: inputArray[index])
            } else {
                guard let current = root.rightChild else { continue }
                setupBinaryTree(inputArray, current, index)
            }
        }
    }
    var order: [Int] = []
    var returnArray: [[Int]] = []
    root.traversePreOrder {
        order.append($0[0])
    }
    returnArray.append(order)
    order = []
    root.traversePostOrder {
        order.append($0[0])
    }
    returnArray.append(order)

    return returnArray
}
```

`setupBinaryTree`ì˜ êµ¬ì¡° (ì¬ê·€í•¨ìˆ˜)

```swift
func setupBinaryTree(_ array: [[Int]], _ current : BinaryNode<[Int]>, _ idx: Int) {

    if current.value[1] > array[idx][1] {
        if current.leftChild == nil {
            current.leftChild = BinaryNode(value: array[idx])
        } else {
            guard let root = current.leftChild else { return }
            setupBinaryTree(array, root, idx)
        }
    } else {
        if current.rightChild == nil {
            current.rightChild = BinaryNode(value: array[idx])
        } else {
            guard let root = current.rightChild else { return }
            setupBinaryTree(array, root, idx)
        }
    }
}

```
